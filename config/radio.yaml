esphome:
  name: radio
  friendly_name: ESP32S3 Radio
  on_boot:
    then:
      - light.turn_on:
          id: status_led
          effect: "Slow Pulse"

esp32:
  board: esp32-s3-devkitc-1
  #cpu_frequency: 240MHZ
  framework:
    type: esp-idf

psram:
  mode: octal
  speed: 40MHz



logger:
  level: WARN

api:

web_server:
  port: 80

ota:
  - platform: esphome
    version: 2

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  on_connect:
    then:
      - component.update: oled_display
  on_disconnect:
    then:
      - component.update: oled_display

http_request:
  useragent: esphome-radio
  verify_ssl: false

i2s_audio:
  id: i2s0
  i2s_bclk_pin:  GPIO10
  i2s_lrclk_pin: GPIO11

speaker:
  - platform: i2s_audio
    id: i2s_spk
    i2s_audio_id: i2s0
    dac_type: external
    i2s_dout_pin: GPIO12     # -> PCM5102A DIN/SD
    sample_rate: 48000
    channel: stereo

  - platform: mixer
    id: mixer_spk
    queue_mode: true
    output_speaker: i2s_spk
    source_speakers:
      - id: announcement_spk
      - id: media_spk

media_player:
  - platform: speaker
    id: s3_radio
    name: "S3 I2S DAC"
    buffer_size: 1000000
    codec_support_enabled: true
    task_stack_in_psram: false
    #internal: true
    volume_initial: 100%

    announcement_pipeline:
      speaker: announcement_spk
      format: MP3
      num_channels: 2

    media_pipeline:
      speaker: media_spk
      format: MP3
      num_channels: 2

globals:
  - id: press_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: station_index
    type: int
    restore_value: true
    initial_value: '0'

  - id: current_name
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: current_url
    type: std::string
    restore_value: no
    initial_value: '""'

text_sensor:
  - platform: template
    id: current_station
    name: "Current Station"
    internal: True

switch:
  - platform: homeassistant
    internal: false
    name: "Stereo"
    id: garage_stereo
    entity_id: switch.garage_stereo

binary_sensor:
  - platform: gpio
    id: radio_button
    pin:
      number: 18
      mode: INPUT_PULLUP
      inverted: true
    name: "Radio Button"
    internal: true
    filters:
      - settle: 15ms
      #- delayed_on: 50ms     # must stay pressed ≥x ms to register
      - delayed_off: 30ms     # avoid quick release glitches
    on_press:
      then:
        - script.execute: button_press
    on_release:
      then:
        - script.execute: button_release

output:
  - platform: ledc
    pin: 5
    id: led_pwm

light:
  - platform: monochromatic
    name: "Status LED"
    output: led_pwm
    id: status_led
    default_transition_length: 0s
    effects:
      - pulse:
          name: "Slow Pulse"
          transition_length: 2s
          update_interval: 4s
          min_brightness: 0%
          max_brightness: 20%
      - strobe:
          name: "Fast Blink"
          colors:
            - state: true
              brightness: 60%
              duration: 100ms
            - state: false
              duration: 100ms
  - platform: esp32_rmt_led_strip
    id: onboard_rgb
    name: "Onboard RGB"
    pin: GPIO48
    num_leds: 1
    chipset: WS2812
    rgb_order: GRB
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10      # lower = slower
          width: 1

script:
  - id: button_press
    mode: restart
    then:
      - light.turn_on:
          id: status_led
          brightness: 100%
          effect: "none"
      # Record time when pressed
      - lambda: 'id(press_time) = millis();'
      - script.execute: long_press_watcher
  - id: button_release
    mode: restart
    then:
      - script.stop: long_press_watcher
      - lambda: |-
          unsigned long held = millis() - id(press_time);

          //reset the timer to avoid double trigger
          id(press_time) = 0;

          if (held < 50) {
            // Skip very short presses
          }
          else
          if (held < 700) {
            // Short press
            ESP_LOGI("button", "Short press: %lu ms", held);
            id(button_next).execute();
          }
          else
          {
            // Long press
            ESP_LOGI("button", "Long press: %lu ms", held);
            id(button_stop).execute();
          }
  - id: long_press_watcher
    mode: restart
    then:
      - if:
          condition:
            binary_sensor.is_on: radio_button
          then:
            - delay: 710ms
            - light.turn_on:
                id: status_led
                effect: "Fast Blink"
            - text_sensor.template.publish:
                id: current_station
                state: !lambda 'return "BYE!";'
            - component.update: oled_display
  - id: play_station_by_index
    then:
      - light.turn_on:
          id: status_led
          brightness: 30%
          effect: "none"
      #- light.turn_on:
      #    id: onboard_rgb
      #    brightness: 50%
       #   effect: Rainbow
      - switch.turn_on: garage_stereo
      - lambda: |-
          static const struct {
            const char* name;
            const char* url;
          } stations[] = {
            { "Qmusic",   "https://stream.qmusic.nl/qmusic/mp3" },
            { "Radio 538","https://www.mp3streams.nl/zender/radio-538/stream/4-mp3-128" },
            { "Sky Radio","https://www.mp3streams.nl/zender/skyradio/stream/8-mp3-128" },
            { "Veronica", "https://www.mp3streams.nl/zender/veronica/stream/11-mp3-128" },
          };

          int index = id(station_index);
          if (index < 0 || index >= (int)(sizeof(stations)/sizeof(stations[0]))) {
            index = 0;
            id(station_index) = index;
          }
          id(current_name) = stations[index].name;
          id(current_url)  = stations[index].url;

      - text_sensor.template.publish:
          id: current_station
          state: !lambda 'return id(current_name);'

      - component.update: oled_display

      - media_player.volume_set:
          id: s3_radio
          volume: 1.0

      - media_player.play_media:
          id: s3_radio
          media_url: !lambda 'return id(current_url);'

  - id: next_station
    then:
      - lambda: |-
          id(station_index)++;
      - script.execute: play_station_by_index

  - id: button_next
    then:
      - if:
          condition:
            or:
              - media_player.is_playing: s3_radio
              - media_player.is_on: s3_radio
          then:
            - script.execute: next_station
          else:
            - media_player.turn_on:
                id: s3_radio
            - text_sensor.template.publish:
                id: current_station
                state: !lambda 'return "HELLO";'
            - component.update: oled_display
            - delay: 250ms
            - script.execute: play_station_by_index

  - id: button_stop
    then:
      - if:
          condition:
            or:
              - media_player.is_playing: s3_radio
              - media_player.is_on: s3_radio
          then:
            - script.execute: stop_radio
          else:
            - script.execute: button_next

  - id: stop_radio
    then:
      - media_player.turn_off:
          id: s3_radio
      - media_player.stop:
          id: s3_radio
      - switch.turn_off: garage_stereo
      - text_sensor.template.publish:
          id: current_station
          state: !lambda 'return "OFF";'
      - component.update: oled_display
      #- light.turn_off: onboard_rgb
      #- light.turn_off: status_led
      - light.turn_on:
          id: status_led
          effect: "Slow Pulse"
      - delay: 500ms
      - text_sensor.template.publish:
          id: current_station
          state: !lambda 'return "";'
      - component.update: oled_display

button:
  - platform: template
    name: "Play/Next"
    on_press:
      - script.execute: button_next

  - platform: template
    name: "Stop"
    on_press:
      - script.execute: stop_radio


font:
  - file: "gfonts://Roboto"
    id: small
    size: 12
  - file: "gfonts://Roboto"
    id: large
    size: 28

i2c:
  - id: bus_display
    sda: GPIO15
    scl: GPIO16
    scan: false
    frequency: 400kHz
  - id: bus_sht
    #frequency: 100kHz
    sda: 14
    scl: 13
    scan: true

sensor:
  - platform: aht10
    variant: AHT20
    i2c_id: bus_sht
    address: 0x38
    humidity:
      id: humidity
      name: "Panel Humidity"
    temperature:
      id: temperature
      name: "Panel Temperature"

  - platform: bmp280_i2c
    i2c_id: bus_sht
    address: 0x77
    pressure:
      id: pressure
      name: "Panel Pressure"

time:
  - platform: sntp
    id: esptime
    timezone: Europe/Amsterdam

display:
  - platform: ssd1306_i2c
    i2c_id: bus_display
    model: "SSD1306 128x64"
    id: oled_display
    address: 0x3C
    update_interval: 4s
    lambda: |-
      if (!esphome::wifi::global_wifi_component->is_connected()) {
        it.printf(64, 0, id(small), TextAlign::TOP_CENTER, "no wifi");
      }
      
      if ((id(current_station).state.empty())) {
        return;
      }
      it.printf(0,   0,   id(small), TextAlign::TOP_LEFT,  "%.1f°C", id(temperature).state);
      it.printf(127, 0,   id(small), TextAlign::TOP_RIGHT, "%.0f%%", id(humidity).state);
      const int y_header_line = 13;
      const int y_footer_line = 51;
      it.line(0, y_header_line, 127, y_header_line);
      it.line(0, y_footer_line, 127, y_footer_line);
      it.printf(64, 31, id(large), TextAlign::CENTER, "%s", id(current_station).state.c_str());
      it.strftime(0,   64, id(small), TextAlign::BOTTOM_LEFT,  "%d/%m", id(esptime).now());
      it.strftime(127, 64, id(small), TextAlign::BOTTOM_RIGHT, "%H:%M", id(esptime).now());
