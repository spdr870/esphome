esphome:
  name: radio
  friendly_name: ESP32S3 Radio
  includes:
    - radio_stations.h
  on_boot:
    then:
      - light.turn_on:
          id: status_led
          effect: "Slow Pulse"

esp32:
  board: esp32-s3-devkitc-1
  #cpu_frequency: 240MHZ
  framework:
    type: esp-idf

psram:
  mode: octal
  speed: 40MHz

logger:
  level: WARN

api:

web_server:
  port: 80

ota:
  - platform: esphome
    version: 2

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  on_connect:
    then:
      - component.update: oled_display
  on_disconnect:
    then:
      - component.update: oled_display

http_request:
  useragent: esphome-radio
  verify_ssl: false

i2s_audio:
  id: i2s0
  i2s_bclk_pin:  GPIO10
  i2s_lrclk_pin: GPIO11

speaker:
  - platform: i2s_audio
    id: i2s_spk
    i2s_audio_id: i2s0
    dac_type: external
    i2s_dout_pin: GPIO12     # -> PCM5102A DIN/SD
    sample_rate: 48000
    channel: stereo

  - platform: mixer
    id: mixer_spk
    queue_mode: true
    output_speaker: i2s_spk
    source_speakers:
      - id: announcement_spk
      - id: media_spk

media_player:
  - platform: speaker
    id: s3_radio
    name: "S3 I2S DAC"
    buffer_size: 800000
    codec_support_enabled: true
    task_stack_in_psram: false
    volume_initial: 100%

    announcement_pipeline:
      speaker: announcement_spk
      format: MP3
      num_channels: 2

    media_pipeline:
      speaker: media_spk
      format: MP3
      num_channels: 2

globals:
  - id: press_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: station_index
    type: int
    restore_value: true
    initial_value: '0'

  - id: current_name
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: current_url
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: in_menu_mode
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: menu_station_index
    type: int
    restore_value: no
    initial_value: '0'

  - id: menu_timeout_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: menu_timeout_ms
    type: int
    restore_value: no
    initial_value: '1000'

text_sensor:
  - platform: template
    id: current_station
    name: "Current Station"
    internal: True

switch:
  - platform: homeassistant
    internal: false
    name: "Stereo"
    id: garage_stereo
    entity_id: switch.garage_stereo

binary_sensor:
  - platform: gpio
    id: radio_button
    pin:
      number: 18
      mode: INPUT_PULLUP
      inverted: true
    name: "Radio Button"
    internal: true
    filters:
      - settle: 15ms
      #- delayed_on: 50ms     # must stay pressed ≥x ms to register
      - delayed_off: 30ms     # avoid quick release glitches
    on_press:
      then:
        - script.execute: button_press
    on_release:
      then:
        - script.execute: button_release

output:
  - platform: ledc
    pin: 5
    id: led_pwm

light:
  - platform: monochromatic
    internal: True
    name: "Status LED"
    output: led_pwm
    id: status_led
    default_transition_length: 0s
    effects:
      - pulse:
          name: "Slow Pulse"
          transition_length: 2s
          update_interval: 2s
          min_brightness: 0%
          max_brightness: 20%
      - strobe:
          name: "Fast Blink"
          colors:
            - state: true
              brightness: 60%
              duration: 100ms
            - state: false
              duration: 100ms
  - platform: esp32_rmt_led_strip
    id: onboard_rgb
    internal: True
    name: "Onboard RGB"
    pin: GPIO48
    num_leds: 1
    chipset: WS2812
    rgb_order: GRB
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10      # lower = slower
          width: 1

script:
  - id: button_press
    mode: restart
    then:
      - light.turn_on:
          id: status_led
          brightness: 100%
          effect: "none"
      # Record time when pressed
      - lambda: 'id(press_time) = millis();'
      - script.execute: long_press_watcher
  - id: button_release
    mode: restart
    then:
      - script.stop: long_press_watcher
      - lambda: |-
          unsigned long held = millis() - id(press_time);

          //reset the timer to avoid double trigger
          id(press_time) = 0;

          if (held < 50) {
            // Skip very short presses
          }
          else
          if (held < 700) {
            // Short press
            ESP_LOGI("button", "Short press: %lu ms", held);
            id(button_short_press).execute();
          }
          else
          {
            // Long press
            ESP_LOGI("button", "Long press: %lu ms", held);
            id(button_stop).execute();
          }
  - id: long_press_watcher
    mode: restart
    then:
      - if:
          condition:
            binary_sensor.is_on: radio_button
          then:
            - delay: 710ms
            - light.turn_on:
                id: status_led
                effect: "Fast Blink"
            - text_sensor.template.publish:
                id: current_station
                state: !lambda 'return "BYE!";'
            - component.update: oled_display

  - id: button_short_press
    then:
      - if:
          condition:
            lambda: 'return id(in_menu_mode);'
          then:
            # Already in menu mode - navigate to next station
            - script.execute: menu_next_station
          else:
            # Check if radio is off, if so turn it on first
            - if:
                condition:
                  not:
                    or:
                      - media_player.is_playing: s3_radio
                      - media_player.is_on: s3_radio
                then:
                  # Radio is off - turn it on with last station
                  - media_player.turn_on:
                      id: s3_radio
                  - text_sensor.template.publish:
                      id: current_station
                      state: !lambda 'return "HELLO";'
                  - component.update: oled_display
                  - delay: 250ms
                  - script.execute: play_station_by_index
                else:
                  # Radio is on - enter menu mode
                  - lambda: |-
                      id(in_menu_mode) = true;
                      id(menu_station_index) = id(station_index);
                      id(menu_timeout_time) = millis() + id(menu_timeout_ms);
                  - component.update: oled_display
                  - script.execute: menu_timeout_watcher

  - id: menu_next_station
    then:
      - lambda: |-
          id(menu_station_index) = (id(menu_station_index) + 1) % NUM_STATIONS;
          id(menu_timeout_time) = millis() + id(menu_timeout_ms);
      - component.update: oled_display

  - id: menu_timeout_watcher
    mode: restart
    then:
      - while:
          condition:
            lambda: 'return id(in_menu_mode);'
          then:
            - delay: 100ms
            - lambda: |-
                if (millis() >= id(menu_timeout_time)) {
                  id(in_menu_mode) = false;
                  // Change to selected station if different
                  if (id(menu_station_index) != id(station_index)) {
                    id(station_index) = id(menu_station_index);
                    id(play_station_by_index).execute();
                  } else {
                    // Just update display to show current station in large font
                    id(oled_display).update();
                  }
                }

  - id: exit_menu
    then:
      - lambda: |-
          id(in_menu_mode) = false;
          // Change to selected station if different
          if (id(menu_station_index) != id(station_index)) {
            id(station_index) = id(menu_station_index);
            id(play_station_by_index).execute();
          }
      - component.update: oled_display

  - id: play_station_by_index
    then:
      - light.turn_on:
          id: status_led
          brightness: 30%
          effect: "none"
      #- light.turn_on:
      #    id: onboard_rgb
      #    brightness: 50%
       #   effect: Rainbow
      - switch.turn_on: garage_stereo
      - lambda: |-
          int index = id(station_index);
          if (index < 0 || index >= NUM_STATIONS) {
            index = 0;
            id(station_index) = index;
          }
          id(current_name) = STATIONS[index].name;
          id(current_url)  = STATIONS[index].url;

      - text_sensor.template.publish:
          id: current_station
          state: !lambda 'return id(current_name);'

      - component.update: oled_display

      - media_player.volume_set:
          id: s3_radio
          volume: 1.0

      - media_player.play_media:
          id: s3_radio
          media_url: !lambda 'return id(current_url);'

  - id: next_station
    then:
      - lambda: |-
          id(station_index)++;
      - script.execute: play_station_by_index

  - id: button_next
    then:
      - if:
          condition:
            or:
              - media_player.is_playing: s3_radio
              - media_player.is_on: s3_radio
          then:
            - script.execute: next_station
          else:
            - media_player.turn_on:
                id: s3_radio
            - text_sensor.template.publish:
                id: current_station
                state: !lambda 'return "HELLO";'
            - component.update: oled_display
            - delay: 250ms
            - script.execute: play_station_by_index

  - id: button_stop
    then:
      - if:
          condition:
            or:
              - media_player.is_playing: s3_radio
              - media_player.is_on: s3_radio
          then:
            - script.execute: stop_radio
          else:
            - script.execute: button_next

  - id: stop_radio
    then:
      - media_player.turn_off:
          id: s3_radio
      - media_player.stop:
          id: s3_radio
      - switch.turn_off: garage_stereo
      - text_sensor.template.publish:
          id: current_station
          state: !lambda 'return "OFF";'
      - component.update: oled_display
      #- light.turn_off: onboard_rgb
      #- light.turn_off: status_led
      - light.turn_on:
          id: status_led
          effect: "Slow Pulse"
      - delay: 500ms
      - text_sensor.template.publish:
          id: current_station
          state: !lambda 'return "";'
      - component.update: oled_display

button:
  - platform: template
    name: "Play/Next"
    on_press:
      - script.execute: button_next

  - platform: template
    name: "Stop"
    on_press:
      - script.execute: stop_radio


font:
  - file: "gfonts://Roboto"
    id: small
    size: 12
  - file: "gfonts://Roboto"
    id: menuheaderfont
    size: 15
  - file: "gfonts://Roboto"
    id: menufont
    size: 12
  - file: "gfonts://Roboto"
    id: large
    size: 28

i2c:
  - id: bus_display
    sda: GPIO15
    scl: GPIO16
    scan: false
    frequency: 400kHz
  - id: bus_sht
    #frequency: 100kHz
    sda: 14
    scl: 13
    scan: true

sensor:
  - platform: aht10
    variant: AHT20
    i2c_id: bus_sht
    address: 0x38
    humidity:
      id: humidity
      name: "Panel Humidity"
    temperature:
      id: temperature
      name: "Panel Temperature"

  - platform: bmp280_i2c
    i2c_id: bus_sht
    address: 0x77
    pressure:
      id: pressure
      name: "Panel Pressure"

time:
  - platform: sntp
    id: esptime
    timezone: Europe/Amsterdam

display:
  - platform: ssd1306_i2c
    i2c_id: bus_display
    model: "SSD1306 128x64"
    id: oled_display
    address: 0x3C
    update_interval: 4s
    lambda: |-
      const int y_header_line = 13;
      const int y_footer_line = 51;
      
      // Check if in menu mode
      if (id(in_menu_mode)) {
        // Menu mode - show all stations in two columns
        const int col_width = 64;
        const int menu_font_size = 12;
        const int start_y = 16;  // Start below 16px header with padding
        const int line_height = menu_font_size + 2;  // Increased for larger font
        
        // Display header
        it.printf(64, 0, id(menuheaderfont), TextAlign::TOP_CENTER, "Select Station");

        //it.line(0, y_header_line, 127, y_header_line);

        // Display stations in two columns
        for (int i = 0; i < NUM_STATIONS; i++) {
          int col = i % 2;
          int row = i / 2;
          int x = col * col_width + col_width / 2;
          int y = start_y + row * line_height;
          
          // Draw filled rectangle background for current selection
          if (i == id(menu_station_index)) {
            // Fixed rectangle size based on column width
            int rect_width = col_width - 4;  // Leave 2px margin on each side
            int rect_height = 14;
            int rect_x = col * col_width + 2;
            int rect_y = y;
            
            // Draw filled rectangle
            it.filled_rectangle(rect_x, rect_y, rect_width, rect_height);
            
            // Draw text in black (inverted for white background)
            it.print(x, y, id(menufont), COLOR_OFF, TextAlign::TOP_CENTER, STATIONS[i].name);
          } else {
            // Normal white text
            it.printf(x, y, id(menufont), TextAlign::TOP_CENTER, "%s", STATIONS[i].name);
          }
        }
        
        return;
      }

      if (!esphome::wifi::global_wifi_component->is_connected()) {
        it.printf(64, 0, id(small), TextAlign::TOP_CENTER, "no wifi");
      }
      
      // Normal mode - show current station in large font
      if ((id(current_station).state.empty())) {
        return;
      }

      it.printf(0,   0,   id(small), TextAlign::TOP_LEFT,  "%.1f°C", id(temperature).state);
      it.printf(127, 0,   id(small), TextAlign::TOP_RIGHT, "%.0f%%", id(humidity).state);

      it.line(0, y_header_line, 127, y_header_line);
      it.line(0, y_footer_line, 127, y_footer_line);
      it.printf(64, 31, id(large), TextAlign::CENTER, "%s", id(current_station).state.c_str());
      it.strftime(0,   64, id(small), TextAlign::BOTTOM_LEFT,  "%d/%m", id(esptime).now());
      it.strftime(127, 64, id(small), TextAlign::BOTTOM_RIGHT, "%H:%M", id(esptime).now());
